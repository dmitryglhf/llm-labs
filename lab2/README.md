# Лабораторная работа 2: Мультиагентная система для учёбы и продуктивности

Реализация мультиагентной системы (МАС) с использованием LangChain и LangGraph для помощи в учебных и повседневных задачах.

## Установка и запуск

### Зависимости

Установите зависимости через uv:

```bash
uv sync --group lab2
```

### Конфигурация

Создайте файл `.env` с параметрами подключения к серверу vLLM:

```bash
OPENAI_BASE_URL=http://your-server:port/v1
OPENAI_API_KEY=your_api_key
MODEL_NAME=qwen3-32b
```

### Запуск

Запустите интерактивный ноутбук:

```bash
marimo edit lab2/notebook.py
```

## Архитектура системы

### Агенты системы

Система состоит из четырёх специализированных агентов, каждый из которых отвечает за определённую область функциональности.

**Агент-роутер (Router Agent)** является точкой входа в систему. Он принимает запрос пользователя, анализирует его содержание и классифицирует по типу: теоретический вопрос, запрос на планирование или общий запрос. На основе классификации роутер принимает решение о передаче управления соответствующему специализированному агенту. Классификация выполняется через вызов LLM с промптом, содержащим описание категорий и контекст предыдущих взаимодействий. Результатом работы роутера является структурированный объект QueryClassification с типом запроса, уровнем уверенности (confidence score) и обоснованием решения.

**Агент теории (Theory Agent)** специализируется на ответах на концептуальные и теоретические вопросы о мультиагентных системах, больших языковых моделях, машинном обучении и смежных академических темах. Этот агент имеет доступ к инструментам поиска информации в Wikipedia (search_wikipedia и get_wikipedia_article), которые он использует для получения актуальных теоретических сведений. При формировании ответа агент учитывает историю предыдущих теоретических вопросов пользователя, что обеспечивает преемственность и глубину объяснений. Результат работы агента представляет собой структурированный ответ с указанием ключевых концепций, ссылок на источники и детальных объяснений.

**Агент планирования (Planning Agent)** отвечает за создание учебных планов, расписаний, рекомендаций по организации времени, а также за помощь в программировании и поиске кода. В его распоряжении находятся расширенный набор инструментов: для работы со временем (get_current_time), создания структурированных планов обучения (create_study_plan), управления учебными материалами (list_study_materials, read_study_material), веб-поиска документации и примеров кода (web_search), навигации по файловой системе проекта (list_files) и чтения исходного кода (read_code_file). Агент генерирует планы с разбиением на конкретные задачи, временные оценки, этапы и контрольные точки. При программировании предоставляет примеры кода, ссылки на документацию и помогает навигироваться по проекту. Результат включает структурированный план в формате JSON, список рекомендаций и оценку необходимого времени.

**Агент памяти (Memory Agent)** играет двойную роль в системе. Во-первых, он управляет персистентным хранением истории взаимодействий, сохраняя и загружая данные из JSON-файла через инструменты save_memory и load_memory. Во-вторых, он выполняет финальную обработку результатов работы других агентов, формируя итоговый ответ пользователю. Агент памяти анализирует сессию, извлекает паттерны поведения пользователя (предпочитаемый стиль ответов, области интересов, уровень технической подготовки), создаёт краткое резюме сессии и формирует список действий для последующего выполнения.

### Реализованные паттерны МАС

Система реализует паттерн **Router + Specialized Agents** с условной маршрутизацией (Conditional Routing).

В этом паттерне агент-роутер выступает в роли диспетчера, принимающего решение о том, какой из специализированных агентов должен обработать запрос. Роутер не выполняет работу сам, а делегирует её наиболее подходящему агенту на основе анализа входных данных. Ключевое отличие от паттерна supervisor заключается в том, что роутер принимает решение один раз в начале обработки запроса, после чего управление полностью переходит к выбранному агенту.

Условная маршрутизация реализуется через механизм conditional edges в LangGraph. После узла роутера граф имеет три возможных пути: к агенту теории (при классификации 'theory'), к агенту планирования (при классификации 'planning') или напрямую к агенту памяти (при классификации 'general'). Таким образом, на основе одного запроса активируется только один специализированный агент, что обеспечивает эффективность работы системы.

После завершения работы специализированного агента (теории или планирования) управление всегда передаётся агенту памяти для финализации ответа и обновления истории сессии.

### Поток управления и данных

Ниже представлена ASCII-схема, показывающая движение запроса через систему от момента поступления до генерации финального ответа.

```
                           ┌──────────────────────────┐
                           │  Запрос пользователя     │
                           │  (query)                 │
                           └──────────┬───────────────┘
                                      │
                                      │ [state.query]
                                      ▼
                           ┌──────────────────────────┐
                           │   Агент-роутер           │
                           │   Анализ и классификация │
                           │   запроса                │
                           └──────────┬───────────────┘
                                      │
                                      │ [state.classification]
                                      │
                         ┌────────────┼───────────┐
                         │            │           │
                  classification  classification  classification
                    == 'theory'   == 'planning'   == 'general'
                         │            │           │
                         ▼            ▼           ▼
              ┌──────────────┐  ┌──────────────┐  │
              │ Агент теории │  │    Агент     │  │
              │              │  │ планирования │  │
              │ [Tools:      │  │              │  │
              │  Wikipedia]  │  │ [Tools:      │  │
              │              │  │  Time, Plan] │  │
              └──────┬───────┘  └──────┬───────┘  │
                     │                 │           │
                     │ [theory_       │ [planning_│
                     │  response]     │  response]│
                     │                 │           │
                     └────────┬────────┴───────────┘
                              │
                              │ [Все пути сходятся]
                              ▼
                     ┌─────────────────────┐
                     │   Агент памяти      │
                     │   Финализация       │
                     │                     │
                     │   [Tools: Memory]   │
                     │                     │
                     │ 1. Загрузка памяти  │
                     │ 2. Анализ сессии    │
                     │ 3. Формирование     │
                     │    ответа           │
                     │ 4. Сохранение памяти│
                     └──────────┬──────────┘
                                │
                                │ [state.final_response,
                                │  state.memory_update]
                                ▼
                     ┌─────────────────────┐
                     │  Финальный ответ    │
                     │  пользователю       │
                     └─────────────────────┘
```

Передача управления (handoff) происходит в двух ключевых точках:

1. **От роутера к специализированному агенту**: После классификации запроса функция route_query возвращает имя узла ('theory', 'planning' или 'memory'), и LangGraph автоматически активирует соответствующий узел графа.

2. **От специализированного агента к агенту памяти**: Это безусловная передача управления через обычные рёбра (edges) графа. Все специализированные агенты всегда передают управление агенту памяти.

### Использование инструментов (Tool Calling)

Tool calling реализован через механизм LangChain agents, который позволяет агентам принимать решения о необходимости вызова инструментов на основе запроса пользователя.

**Агент теории** имеет доступ к двум инструментам:

1. `search_wikipedia(query, max_results)` - выполняет поиск в Wikipedia по ключевым словам и возвращает краткие саммари найденных статей. Используется для быстрого получения определений и обзорной информации.

2. `get_wikipedia_article(title)` - получает полный текст статьи из Wikipedia по точному названию. Сохраняет полный текст в папку study_materials для последующего использования и возвращает расширенное саммари.

Агент вызывает эти инструменты автоматически при обнаружении в запросе необходимости получения фактической информации о теоретических концепциях.

**Агент планирования** использует семь инструментов:

1. `get_current_time()` - возвращает текущую дату и время. Используется для привязки планов к реальным датам.

2. `create_study_plan(topic, duration_hours)` - генерирует структурированный план обучения с разбиением на сессии, указанием ресурсов и временных рамок. Возвращает JSON-структуру с расписанием.

3. `list_study_materials(folder)` - возвращает список всех ранее загруженных учебных материалов из указанной папки.

4. `read_study_material(filename)` - читает содержимое конкретного учебного материала. Возвращает первые 2000 символов для предпросмотра.

5. `web_search(query, max_results, region, safesearch)` - выполняет поиск в интернете через DuckDuckGo. Возвращает отформатированный список результатов с заголовками, URL и описаниями. Используется для поиска документации, туториалов и примеров кода.

6. `list_files(relative_path)` - перечисляет файлы и директории в проекте. Используется для навигации по структуре проекта и поиска нужных файлов.

7. `read_code_file(relative_path)` - читает содержимое файла с кодом из проекта. Возвращает содержимое файла (или первые 200 строк для больших файлов). Используется для анализа существующего кода.

Агент планирования использует эти инструменты для создания реалистичных планов с учётом доступных ресурсов, текущего времени, поиска документации и навигации по проектным файлам.

**Агент памяти** работает с двумя инструментами персистентности:

1. `save_memory(session_history, user_preferences)` - сохраняет историю сессий и пользовательские предпочтения в JSON-файл lab2_memory.json. Принимает JSON-строки и записывает их вместе с timestamp последнего обновления.

2. `load_memory()` - загружает сохранённую историю и предпочтения из файла. Если файл не существует, возвращает пустую структуру.

Эти инструменты обеспечивают персистентность данных между запусками системы.

### Управление памятью

Память в системе организована на трёх уровнях:

**Уровень 1: Оперативная память (State)**

Состояние графа (MultiAgentState) содержит всю информацию о текущем выполнении запроса: исходный запрос пользователя, результаты классификации, ответы специализированных агентов, историю сессии и пользовательские предпочтения. Это состояние передаётся между узлами графа и изменяется по мере обработки запроса. История сессии (session_history) накапливает информацию о всех запросах в рамках одного запуска системы.

**Уровень 2: Персистентное хранилище (JSON-файл)**

Файл lab2_memory.json содержит долгосрочную память системы. В нём хранится история всех сессий с временными метками и извлечёнными паттернами поведения пользователя. Структура файла:

```json
{
  "session_history": [
    {
      "query": "...",
      "classification": "theory",
      "confidence": 0.95,
      "timestamp": "2024-...",
      "summary": "..."
    },
    ...
  ],
  "user_preferences": {
    "topics_of_interest": [...],
    "preferred_style": "detailed",
    "technical_level": "advanced"
  },
  "last_updated": "2024-12-13T..."
}
```

**Уровень 3: Контекстная инъекция**

При каждом запросе агент памяти загружает сохранённую историю через load_memory и передаёт её как контекст другим агентам. Агент-роутер использует последние 3 запроса из истории для улучшения точности классификации. Специализированные агенты получают релевантную часть истории (только теоретические вопросы для агента теории, только планы для агента планирования) для обеспечения преемственности в диалоге.

**Влияние на последующие шаги:**

Память влияет на работу системы следующим образом:

1. Роутер учитывает предыдущие классификации при определении типа нового запроса, что снижает вероятность ошибок классификации при похожих запросах.

2. Специализированные агенты строят ответы с учётом ранее обсуждённых тем, что позволяет избежать повторений и углублять объяснения.

3. Агент памяти выявляет долгосрочные паттерны (предпочитаемые темы, стиль ответов) и формирует профиль пользователя, который влияет на формулировку будущих ответов.

4. Сохранённые в study_materials файлы становятся доступны для повторного использования через инструменты агента планирования.


## Эксперименты и оценка

Система протестирована на пяти запросах различного типа. Все запросы корректно классифицированы с высокой уверенностью (0.95).

Запрос 1 (теория о вызовах МАС с LLM): активирован агент теории, использованы инструменты Wikipedia для получения информации о координации агентов, масштабируемости и управлении знаниями. Ответ содержит детальный анализ пяти ключевых проблем с примерами и ссылками. Память обновлена с указанием интереса пользователя к теоретическим аспектам МАС.

Запрос 2 (план изучения МАС на 10 часов): активирован агент планирования, создан структурированный план с разбиением на 5 сессий по 2 часа, включающий темы от основ до продвинутых концепций и практики. Инструмент create_study_plan сгенерировал JSON со списком задач для каждой сессии. Рекомендации включают перерывы, онлайн-курсы и практические упражнения на платформах JADE и NetLogo.

Запрос 3 (различия между supervisor и sequential workflow): активирован агент теории, выполнен поиск по обоим паттернам. Ответ содержит детальное сравнение централизованного управления supervisor против линейной последовательности workflow, таблицу различий по шести критериям и примеры применения. Память зафиксировала углубление в архитектурные паттерны МАС.

Запрос 4 (расписание на 5 дней для LangGraph): активирован агент планирования, создан план с распределением 2 часов в день на изучение концепций графов, манипуляции структурами, оптимизации запросов и реальных применений. Инструмент create_study_plan адаптировал длительность под формат "дни". Рекомендации включают ссылки на учебные материалы (PDF, notebooks, papers из study_materials).

Запрос 5 (координация и коммуникация в МАС): активирован агент теории, поиск информации о протоколах коммуникации и децентрализованных алгоритмах. Ответ объясняет методы координации (переговоры, децентрализованные алгоритмы, MARL), элементы коммуникации (протоколы FIPA-ACL, семантическая совместимость) и связь с Distributed AI. Приведены примеры применения в робототехнике и логистике.

Неформальная оценка по критериям:

Корректность маршрутизации: 100% (5 из 5 запросов направлены к нужному агенту). Роутер использует контекст предыдущих запросов для повышения точности классификации.

Использование инструментов: осмысленное и целевое. Агент теории обращается к Wikipedia для фактов, агент планирования создает структурированные планы через create_study_plan и использует web_search для документации. Ложных вызовов не обнаружено.

Работа с памятью: память активно используется. После каждого запроса агент памяти обновляет session_history, извлекает паттерны поведения (темы интереса, стиль ответов) и сохраняет в JSON. Последующие запросы учитывают накопленный контекст для построения связных объяснений.

Субъективная полезность: ответы содержат детальные объяснения с терминологией, ссылками, примерами. Планы структурированы с разбивкой на этапы и ресурсы. Система пригодна для реального использования при изучении МАС и планировании учебных задач.

Ограничения: иногда ответы избыточны по объему. Агент планирования генерирует общие рекомендации, не всегда учитывая специфику темы. Инструменты Wikipedia иногда не находят точных совпадений для специфичных терминов из МАС.

## Рефлексия

Хорошо сработали: паттерн роутера с условной маршрутизацией обеспечил четкое разделение ответственности между агентами без конфликтов. Использование memory agent для финализации ответов позволило централизовать управление историей и избежать дублирования логики сохранения. Tool calling через LangChain agents упростил интеграцию инструментов без необходимости ручного парсинга и маршрутизации вызовов.

Неожиданное поведение: роутер иногда классифицирует запросы о применении теории как "planning" вместо "theory", что связано с неоднозначностью формулировок. Агент планирования при создании планов иногда генерирует избыточное количество ресурсов, не все из которых релевантны. Wikipedia search иногда возвращает статьи на неправильном языке, несмотря на русскоязычный запрос.

Направления развития: добавить агента-ревьюера для проверки качества ответов перед финализацией (supervisor pattern поверх существующей архитектуры). Реализовать RAG для работы с локальной базой знаний вместо зависимости от Wikipedia. Расширить набор инструментов агента планирования: интеграция с календарями, трекерами задач, Git для анализа истории проектов. Улучшить память через векторную БД для семантического поиска по истории вместо простого списка.
